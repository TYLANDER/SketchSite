import Foundation

// MARK: - Production API Key Manager

class ProductionAPIKeys {
    static let shared = ProductionAPIKeys()
    private init() {}
    
    // Set this to true to test embedded keys in debug builds
    static let useEmbeddedKeysInDebug = true
    
    // MARK: - Production API Key Configuration
    
    /// Replace these with your obfuscated API keys before App Store submission
    /// Use the APIKeyObfuscator utility to generate these arrays:
    ///
    /// 1. Get your API keys:
    ///    - OpenAI: https://platform.openai.com/api-keys
    ///    - Anthropic: https://console.anthropic.com/
    ///
    /// 2. Use the helper function below to generate obfuscated arrays
    ///
    /// 3. Replace the empty arrays below with the generated byte arrays
    
    // SIMPLE KEY EMBEDDING HELPER - CALL THIS TO GET YOUR OBFUSCATED ARRAYS
    static func generateObfuscatedArrays(openAIKey: String, anthropicKey: String) {
        print("üîë COPY THE ARRAYS BELOW INTO ChatGPTService.swift:")
        print("")
        print("// OpenAI Key Array:")
        print("private static let obfuscatedOpenAIKey: [UInt8] = [")
        let openAIBytes = openAIKey.utf8.map { $0 ^ 0x42 }
        print(openAIBytes.map(String.init).joined(separator: ", "))
        print("]")
        print("")
        print("// Anthropic Key Array:")
        print("private static let obfuscatedAnthropicKey: [UInt8] = [")
        let anthropicBytes = anthropicKey.utf8.map { $0 ^ 0x42 }
        print(anthropicBytes.map(String.init).joined(separator: ", "))
        print("]")
        print("")
        print("üîë COPY THE ARRAYS ABOVE INTO ChatGPTService.swift")
    }
    
    // Obfuscated OpenAI API key bytes (REPLACE WITH YOUR KEY)
    private static let obfuscatedOpenAIKey: [UInt8] = [

49, 41, 111, 50, 48, 45, 40, 111, 114, 6, 46, 115, 12, 114, 0, 9, 4, 51, 18, 54, 52, 12, 56, 20, 111, 36, 1, 33, 44, 37, 45, 33, 5, 51, 115, 3, 43, 3, 49, 35, 9, 38, 51, 43, 44, 114, 117, 37, 37, 49, 44, 9, 37, 59, 39, 51, 113, 10, 20, 21, 40, 10, 17, 46, 43, 45, 11, 48, 37, 50, 15, 123, 24, 10, 112, 7, 56, 22, 37, 19, 42, 114, 22, 113, 0, 46, 32, 41, 4, 8, 36, 119, 49, 50, 20, 40, 38, 15, 11, 7, 114, 11, 1, 7, 59, 6, 27, 17, 58, 21, 114, 23, 15, 4, 19, 24, 13, 5, 122, 46, 27, 119, 38, 40, 23, 48, 45, 33, 22, 56, 52, 32, 50, 3, 24, 46, 119, 24, 17, 6, 4, 29, 3, 118, 51, 58, 46, 35, 113, 41, 29, 46, 117, 5, 54, 115, 19, 0, 39, 114, 38, 58, 19, 3    ]
    
    // Obfuscated Anthropic API key bytes (REPLACE WITH YOUR KEY)  
    private static let obfuscatedAnthropicKey: [UInt8] = [

49, 41, 111, 35, 44, 54, 111, 35, 50, 43, 114, 113, 111, 18, 117, 51, 55, 11, 4, 33, 36, 115, 58, 52, 115, 116, 112, 46, 116, 112, 6, 44, 53, 42, 22, 9, 48, 1, 54, 23, 23, 13, 55, 38, 114, 32, 46, 15, 43, 7, 23, 46, 50, 49, 32, 19, 116, 23, 12, 39, 52, 114, 48, 48, 10, 45, 6, 36, 7, 18, 15, 44, 39, 13, 58, 38, 18, 18, 5, 23, 113, 4, 41, 122, 118, 51, 33, 118, 59, 39, 1, 17, 123, 42, 42, 117, 46, 45, 3, 111, 39, 122, 23, 23, 59, 37, 3, 3    ]
    
    func getOpenAIKey() -> String {
        #if DEBUG
        if Self.useEmbeddedKeysInDebug && !Self.obfuscatedOpenAIKey.isEmpty {
            // Debug: Use embedded key if available and flag is set
            return deobfuscateKey(Self.obfuscatedOpenAIKey)
        } else {
            // Debug: Fall back to environment variable
            return ProcessInfo.processInfo.environment["OPENAI_API_KEY"] ?? ""
        }
        #else
        // Production: Use embedded key with obfuscation
        return deobfuscateKey(Self.obfuscatedOpenAIKey)
        #endif
    }
    
    func getAnthropicKey() -> String {
        #if DEBUG
        if Self.useEmbeddedKeysInDebug && !Self.obfuscatedAnthropicKey.isEmpty {
            // Debug: Use embedded key if available and flag is set
            return deobfuscateKey(Self.obfuscatedAnthropicKey)
        } else {
            // Debug: Fall back to environment variable  
            return ProcessInfo.processInfo.environment["ANTHROPIC_API_KEY"] ?? ""
        }
        #else
        // Production: Use embedded key with obfuscation
        return deobfuscateKey(Self.obfuscatedAnthropicKey)
        #endif
    }
    
    // MARK: - Key Obfuscation (Basic Security)
    
    private func deobfuscateKey(_ obfuscatedKey: [UInt8]) -> String {
        // Simple XOR deobfuscation
        let deobfuscated = obfuscatedKey.map { $0 ^ 0x42 }
        return String(bytes: deobfuscated, encoding: .utf8) ?? ""
    }
    
    // MARK: - Usage Tracking
    
    private let usageKey = "SketchSite_APIUsage"
    private let dailyLimitKey = "SketchSite_DailyLimit"
    
    func trackUsage() {
        let today = Calendar.current.startOfDay(for: Date())
        let usage = UserDefaults.standard.object(forKey: usageKey) as? [String: Int] ?? [:]
        let todayString = ISO8601DateFormatter().string(from: today)
        
        let currentUsage = usage[todayString] ?? 0
        var newUsage = usage
        newUsage[todayString] = currentUsage + 1
        
        UserDefaults.standard.set(newUsage, forKey: usageKey)
        
        print("üìä API Usage tracked: \(currentUsage + 1) requests today")
    }
    
    func canMakeRequest() -> Bool {
        let today = Calendar.current.startOfDay(for: Date())
        let usage = UserDefaults.standard.object(forKey: usageKey) as? [String: Int] ?? [:]
        let todayString = ISO8601DateFormatter().string(from: today)
        
        let currentUsage = usage[todayString] ?? 0
        let dailyLimit = UserDefaults.standard.integer(forKey: dailyLimitKey)
        let limit = dailyLimit > 0 ? dailyLimit : 100 // Default 100 requests per day
        
        return currentUsage < limit
    }
    
    func getTodayUsage() -> (used: Int, limit: Int) {
        let today = Calendar.current.startOfDay(for: Date())
        let usage = UserDefaults.standard.object(forKey: usageKey) as? [String: Int] ?? [:]
        let todayString = ISO8601DateFormatter().string(from: today)
        
        let currentUsage = usage[todayString] ?? 0
        let dailyLimit = UserDefaults.standard.integer(forKey: dailyLimitKey)
        let limit = dailyLimit > 0 ? dailyLimit : 100
        
        return (used: currentUsage, limit: limit)
    }
}

// MARK: - Enhanced ChatGPT Service

/// Singleton service for interacting with the OpenAI Chat Completions API.
class ChatGPTService {
    static let shared = ChatGPTService()
    private init() {}

    /// Generates front-end code using OpenAI's GPT or Anthropic Claude model, with optional conversation history.
    /// - Parameters:
    ///   - prompt: The main layout or design prompt or follow-up message.
    ///   - model: The model to use (e.g., gpt-4o, gpt-3.5-turbo, claude-3-opus, etc.).
    ///   - conversation: Optional conversation history for prompt chaining.
    ///   - completion: Completion handler with result of model response.
    func generateCode(prompt: String, model: String = "gpt-4o", conversation: [[String: String]]? = nil, completion: @escaping (Result<String, Error>) -> Void) {
        
        // Check usage limits
        guard ProductionAPIKeys.shared.canMakeRequest() else {
            let usage = ProductionAPIKeys.shared.getTodayUsage()
            completion(.failure(APIError.usageLimitExceeded(used: usage.used, limit: usage.limit)))
            return
        }
        
        let isClaude = model.starts(with: "claude")
        let apiKey = isClaude ? ProductionAPIKeys.shared.getAnthropicKey() : ProductionAPIKeys.shared.getOpenAIKey()
        
        // Validate API key
        guard !apiKey.isEmpty else {
            completion(.failure(APIError.missingAPIKey(service: isClaude ? "Anthropic" : "OpenAI")))
            return
        }
        
        let url = isClaude ? URL(string: "https://api.anthropic.com/v1/messages")! : URL(string: "https://api.openai.com/v1/chat/completions")!
        
        // Debug: Log API key info (first 10 chars only for security)
        let keyPrefix = String(apiKey.prefix(10))
        print("üîë Using \(isClaude ? "Anthropic" : "OpenAI") API key: \(keyPrefix)...")
        print("üîë API key length: \(apiKey.count) characters")
        print("üîë API key is valid format: \(apiKey.hasPrefix("sk-") || apiKey.hasPrefix("sk-ant-"))")
        print("üåê Making request to: \(url.absoluteString)")
        
        // Test basic connectivity first
        print("üß™ Testing network connectivity...")
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        if isClaude {
            request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("2023-06-01", forHTTPHeaderField: "anthropic-version")
        } else {
        request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        var requestBody: [String: Any] = [:]
        
        if isClaude {
            var messages: [[String: String]] = conversation ?? []
            messages.append(["role": "user", "content": prompt])
            requestBody = [
                "model": model,
                "max_tokens": 4000,
                "messages": messages
            ]
        } else {
            var messages: [[String: String]] = conversation ?? []
            messages.append(["role": "user", "content": prompt])
            requestBody = [
                "model": model,
                "messages": messages,
                "max_tokens": 4000,
                "temperature": 0.7
            ]
        }
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        } catch {
            completion(.failure(error))
            return
        }
        
        // Track usage before making request
        ProductionAPIKeys.shared.trackUsage()
        
        // Configure URL session with longer timeout for better reliability
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 60.0  // 60 seconds
        config.timeoutIntervalForResource = 120.0 // 2 minutes
        let session = URLSession(configuration: config)
        
        session.dataTask(with: request) { data, response, error in
            if let error = error {
                print("üö´ Network error: \(error.localizedDescription)")
                completion(.failure(error))
                return
            }
            
            // Check HTTP response status
            if let httpResponse = response as? HTTPURLResponse {
                print("üì° HTTP Status: \(httpResponse.statusCode)")
                if httpResponse.statusCode != 200 {
                    let errorMsg = "HTTP \(httpResponse.statusCode): \(HTTPURLResponse.localizedString(forStatusCode: httpResponse.statusCode))"
                    print("üö´ \(errorMsg)")
                    completion(.failure(APIError.apiError(errorMsg)))
                    return
                }
            }
            
            guard let data = data else {
                completion(.failure(APIError.noDataReceived))
                return
            }
            
            do {
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                
                if isClaude {
                    if let content = json?["content"] as? [[String: Any]],
                       let firstContent = content.first,
                       let text = firstContent["text"] as? String {
                        completion(.success(text))
                    } else if let error = json?["error"] as? [String: Any],
                             let message = error["message"] as? String {
                        completion(.failure(APIError.apiError(message)))
                    } else {
                        completion(.failure(APIError.invalidResponse))
                    }
                } else {
                    if let choices = json?["choices"] as? [[String: Any]],
                       let firstChoice = choices.first,
                       let message = firstChoice["message"] as? [String: Any],
                       let content = message["content"] as? String {
                        completion(.success(content))
                    } else if let error = json?["error"] as? [String: Any],
                             let message = error["message"] as? String {
                        completion(.failure(APIError.apiError(message)))
                    } else {
                        completion(.failure(APIError.invalidResponse))
                    }
                }
            } catch {
                completion(.failure(error))
            }
        }.resume()
    }
    
    /// Simple connectivity test for debugging
    func testConnectivity(completion: @escaping (Bool, String) -> Void) {
        print("üß™ Testing basic network connectivity...")
        
        let testURL = URL(string: "https://httpbin.org/get")!
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 10.0
        let session = URLSession(configuration: config)
        
        session.dataTask(with: testURL) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    print("üö´ Basic connectivity test FAILED: \(error.localizedDescription)")
                    completion(false, error.localizedDescription)
                } else if let httpResponse = response as? HTTPURLResponse {
                    print("‚úÖ Basic connectivity test PASSED: HTTP \(httpResponse.statusCode)")
                    completion(true, "Success")
                } else {
                    print("‚ùì Connectivity test unclear")
                    completion(false, "Unknown response")
                }
            }
        }.resume()
    }
}

// MARK: - API Errors

enum APIError: LocalizedError, Equatable {
    case missingAPIKey(service: String)
    case usageLimitExceeded(used: Int, limit: Int)
    case apiError(String)
    case invalidResponse
    case noDataReceived
    
    var errorDescription: String? {
        switch self {
        case .missingAPIKey(let service):
            return "\(service) API key not configured"
        case .usageLimitExceeded(let used, let limit):
            return "Daily usage limit exceeded (\(used)/\(limit)). Try again tomorrow or upgrade to Pro."
        case .apiError(let message):
            return "API Error: \(message)"
        case .invalidResponse:
            return "Invalid response from API"
        case .noDataReceived:
            return "No data received from API"
        }
    }
}
