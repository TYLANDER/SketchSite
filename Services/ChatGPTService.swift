import Foundation

// MARK: - Production API Key Manager

class ProductionAPIKeys {
    static let shared = ProductionAPIKeys()
    private init() {}
    
    // Set this to true to test embedded keys in debug builds
    static let useEmbeddedKeysInDebug = true
    
    // MARK: - Production API Key Configuration
    
    /// Replace these with your obfuscated API keys before App Store submission
    /// Use the APIKeyObfuscator utility to generate these arrays:
    ///
    /// 1. Get your API keys:
    ///    - OpenAI: https://platform.openai.com/api-keys
    ///    - Anthropic: https://console.anthropic.com/
    ///
    /// 2. Use the helper function below to generate obfuscated arrays
    ///
    /// 3. Replace the empty arrays below with the generated byte arrays
    
    // SIMPLE KEY EMBEDDING HELPER - CALL THIS TO GET YOUR OBFUSCATED ARRAYS
    static func generateObfuscatedArrays(openAIKey: String, anthropicKey: String) {
        print("üîë COPY THE ARRAYS BELOW INTO ChatGPTService.swift:")
        print("")
        print("// OpenAI Key Array:")
        print("private static let obfuscatedOpenAIKey: [UInt8] = [")
        let openAIBytes = openAIKey.utf8.map { $0 ^ 0x42 }
        print(openAIBytes.map(String.init).joined(separator: ", "))
        print("]")
        print("")
        print("// Anthropic Key Array:")
        print("private static let obfuscatedAnthropicKey: [UInt8] = [")
        let anthropicBytes = anthropicKey.utf8.map { $0 ^ 0x42 }
        print(anthropicBytes.map(String.init).joined(separator: ", "))
        print("]")
        print("")
        print("üîë COPY THE ARRAYS ABOVE INTO ChatGPTService.swift")
    }
    
    // Obfuscated OpenAI API key bytes (REPLACE WITH YOUR KEY)
    private static let obfuscatedOpenAIKey: [UInt8] = [

49, 41, 111, 50, 48, 45, 40, 111, 114, 6, 46, 115, 12, 114, 0, 9, 4, 51, 18, 54, 52, 12, 56, 20, 111, 36, 1, 33, 44, 37, 45, 33, 5, 51, 115, 3, 43, 3, 49, 35, 9, 38, 51, 43, 44, 114, 117, 37, 37, 49, 44, 9, 37, 59, 39, 51, 113, 10, 20, 21, 40, 10, 17, 46, 43, 45, 11, 48, 37, 50, 15, 123, 24, 10, 112, 7, 56, 22, 37, 19, 42, 114, 22, 113, 0, 46, 32, 41, 4, 8, 36, 119, 49, 50, 20, 40, 38, 15, 11, 7, 114, 11, 1, 7, 59, 6, 27, 17, 58, 21, 114, 23, 15, 4, 19, 24, 13, 5, 122, 46, 27, 119, 38, 40, 23, 48, 45, 33, 22, 56, 52, 32, 50, 3, 24, 46, 119, 24, 17, 6, 4, 29, 3, 118, 51, 58, 46, 35, 113, 41, 29, 46, 117, 5, 54, 115, 19, 0, 39, 114, 38, 58, 19, 3    ]
    
    // Obfuscated Anthropic API key bytes (REPLACE WITH YOUR KEY)  
    private static let obfuscatedAnthropicKey: [UInt8] = [

49, 41, 111, 35, 44, 54, 111, 35, 50, 43, 114, 113, 111, 18, 117, 51, 55, 11, 4, 33, 36, 115, 58, 52, 115, 116, 112, 46, 116, 112, 6, 44, 53, 42, 22, 9, 48, 1, 54, 23, 23, 13, 55, 38, 114, 32, 46, 15, 43, 7, 23, 46, 50, 49, 32, 19, 116, 23, 12, 39, 52, 114, 48, 48, 10, 45, 6, 36, 7, 18, 15, 44, 39, 13, 58, 38, 18, 18, 5, 23, 113, 4, 41, 122, 118, 51, 33, 118, 59, 39, 1, 17, 123, 42, 42, 117, 46, 45, 3, 111, 39, 122, 23, 23, 59, 37, 3, 3    ]
    
    func getOpenAIKey() -> String {
        #if DEBUG
        if Self.useEmbeddedKeysInDebug && !Self.obfuscatedOpenAIKey.isEmpty {
            // Debug: Use embedded key if available and flag is set
            return deobfuscateKey(Self.obfuscatedOpenAIKey)
        } else {
            // Debug: Fall back to environment variable
            return ProcessInfo.processInfo.environment["OPENAI_API_KEY"] ?? ""
        }
        #else
        // Production: Use embedded key with obfuscation
        return deobfuscateKey(Self.obfuscatedOpenAIKey)
        #endif
    }
    
    func getAnthropicKey() -> String {
        #if DEBUG
        if Self.useEmbeddedKeysInDebug && !Self.obfuscatedAnthropicKey.isEmpty {
            // Debug: Use embedded key if available and flag is set
            return deobfuscateKey(Self.obfuscatedAnthropicKey)
        } else {
            // Debug: Fall back to environment variable  
            return ProcessInfo.processInfo.environment["ANTHROPIC_API_KEY"] ?? ""
        }
        #else
        // Production: Use embedded key with obfuscation
        return deobfuscateKey(Self.obfuscatedAnthropicKey)
        #endif
    }
    
    // MARK: - Key Obfuscation (Basic Security)
    
    private func deobfuscateKey(_ obfuscatedKey: [UInt8]) -> String {
        // Simple XOR deobfuscation
        let deobfuscated = obfuscatedKey.map { $0 ^ 0x42 }
        return String(bytes: deobfuscated, encoding: .utf8) ?? ""
    }
    
    // MARK: - Usage Tracking
    
    private let usageKey = "SketchSite_APIUsage"
    private let dailyLimitKey = "SketchSite_DailyLimit"
    
    func trackUsage() {
        let today = Calendar.current.startOfDay(for: Date())
        let usage = UserDefaults.standard.object(forKey: usageKey) as? [String: Int] ?? [:]
        let todayString = ISO8601DateFormatter().string(from: today)
        
        let currentUsage = usage[todayString] ?? 0
        var newUsage = usage
        newUsage[todayString] = currentUsage + 1
        
        UserDefaults.standard.set(newUsage, forKey: usageKey)
        
        print("üìä API Usage tracked: \(currentUsage + 1) requests today")
    }
    
    func canMakeRequest() -> Bool {
        let today = Calendar.current.startOfDay(for: Date())
        let usage = UserDefaults.standard.object(forKey: usageKey) as? [String: Int] ?? [:]
        let todayString = ISO8601DateFormatter().string(from: today)
        
        let currentUsage = usage[todayString] ?? 0
        let dailyLimit = UserDefaults.standard.integer(forKey: dailyLimitKey)
        let limit = dailyLimit > 0 ? dailyLimit : 100 // Default 100 requests per day
        
        return currentUsage < limit
    }
    
    func getTodayUsage() -> (used: Int, limit: Int) {
        let today = Calendar.current.startOfDay(for: Date())
        let usage = UserDefaults.standard.object(forKey: usageKey) as? [String: Int] ?? [:]
        let todayString = ISO8601DateFormatter().string(from: today)
        
        let currentUsage = usage[todayString] ?? 0
        let dailyLimit = UserDefaults.standard.integer(forKey: dailyLimitKey)
        let limit = dailyLimit > 0 ? dailyLimit : 100
        
        return (used: currentUsage, limit: limit)
    }
}

// MARK: - Enhanced ChatGPT Service

/// Singleton service for interacting with the OpenAI Chat Completions API with retry logic and fallback.
class ChatGPTService {
    static let shared = ChatGPTService()
    private init() {}
    
    // MARK: - Request Management
    private let requestQueue = DispatchQueue(label: "api.request.queue", qos: .userInitiated)
    private let semaphore = DispatchSemaphore(value: 3) // Limit concurrent requests
    private var activeRequests: Set<UUID> = []
    private let activeRequestsLock = NSLock()
    
    // MARK: - Retry Configuration
    private let maxRetries = 3
    private let baseDelay: TimeInterval = 2.0 // Base delay for exponential backoff
    private let maxDelay: TimeInterval = 30.0 // Maximum delay between retries
    
    // MARK: - Circuit Breaker Pattern
    private var circuitBreakerState: CircuitBreakerState = .closed
    private var failureCount = 0
    private var lastFailureTime: Date?
    private let failureThreshold = 5 // Open circuit after 5 consecutive failures
    private let recoveryTimeout: TimeInterval = 60.0 // Try to recover after 60 seconds
    
    private enum CircuitBreakerState {
        case closed   // Normal operation
        case open     // Failing, don't attempt requests
        case halfOpen // Testing if service recovered
    }

    /// Generates front-end code using OpenAI's GPT or Anthropic Claude model, with retry logic and fallback.
    /// - Parameters:
    ///   - prompt: The main layout or design prompt or follow-up message.
    ///   - model: The model to use (e.g., gpt-4o, gpt-3.5-turbo, claude-3-opus, etc.).
    ///   - conversation: Optional conversation history for prompt chaining.
    ///   - completion: Completion handler with result of model response.
    func generateCode(prompt: String, model: String = "gpt-4o", conversation: [[String: String]]? = nil, completion: @escaping (Result<String, Error>) -> Void) {
        
        // Check usage limits
        guard ProductionAPIKeys.shared.canMakeRequest() else {
            let usage = ProductionAPIKeys.shared.getTodayUsage()
            completion(.failure(APIError.usageLimitExceeded(used: usage.used, limit: usage.limit)))
            return
        }
        
        // Check circuit breaker state
        if !canMakeRequest() {
            completion(.failure(APIError.serviceUnavailable("AI service temporarily unavailable")))
            return
        }
        
        let requestId = UUID()
        
        // Queue the request to prevent API overload
        requestQueue.async { [weak self] in
            guard let self = self else { return }
            
            // Limit concurrent requests
            self.semaphore.wait()
            
            // Track active request
            self.activeRequestsLock.lock()
            self.activeRequests.insert(requestId)
            self.activeRequestsLock.unlock()
            
            // Attempt request with retry logic and fallback
            self.attemptRequestWithRetry(
                prompt: prompt,
                model: model,
                conversation: conversation,
                requestId: requestId,
                attempt: 1
            ) { result in
                // Clean up
                self.activeRequestsLock.lock()
                self.activeRequests.remove(requestId)
                self.activeRequestsLock.unlock()
                
                self.semaphore.signal()
                
                // Return result on main queue
                DispatchQueue.main.async {
                    completion(result)
                }
            }
        }
    }
    
    private func attemptRequestWithRetry(
        prompt: String,
        model: String,
        conversation: [[String: String]]?,
        requestId: UUID,
        attempt: Int,
        completion: @escaping (Result<String, Error>) -> Void
    ) {
        
        print("üöÄ API Request attempt \(attempt)/\(maxRetries) (ID: \(requestId.uuidString.prefix(8)))")
        
        makeAPIRequest(
            prompt: prompt,
            model: model,
            conversation: conversation
        ) { [weak self] result in
            
            guard let self = self else { return }
            
            switch result {
            case .success(let response):
                print("‚úÖ API Request successful (ID: \(requestId.uuidString.prefix(8)))")
                self.recordSuccess()
                completion(.success(response))
                
            case .failure(let error):
                print("‚ùå API Request failed - attempt \(attempt): \(error.localizedDescription)")
                
                if attempt < self.maxRetries && self.shouldRetry(error: error) {
                    let delay = self.calculateDelay(for: attempt, error: error)
                    print("‚è≥ Retrying in \(delay) seconds...")
                    
                    DispatchQueue.global().asyncAfter(deadline: .now() + delay) {
                        self.attemptRequestWithRetry(
                            prompt: prompt,
                            model: model,
                            conversation: conversation,
                            requestId: requestId,
                            attempt: attempt + 1,
                            completion: completion
                        )
                    }
                } else if attempt >= self.maxRetries && model.contains("gpt-4") {
                    // Try fallback to GPT-3.5-turbo for rate-limited GPT-4 requests
                    print("üîÑ Falling back to GPT-3.5-turbo...")
                    self.attemptRequestWithRetry(
                        prompt: prompt,
                        model: "gpt-3.5-turbo",
                        conversation: conversation,
                        requestId: requestId,
                        attempt: 1, // Reset attempt counter for fallback
                        completion: completion
                    )
                } else {
                    print("üö´ Max retries exceeded or non-retryable error")
                    self.recordFailure()
                    completion(.failure(error))
                }
            }
        }
    }
    
    private func makeAPIRequest(
        prompt: String,
        model: String,
        conversation: [[String: String]]?,
        completion: @escaping (Result<String, Error>) -> Void
    ) {
        
        let isClaude = model.starts(with: "claude")
        let apiKey = isClaude ? ProductionAPIKeys.shared.getAnthropicKey() : ProductionAPIKeys.shared.getOpenAIKey()
        
        // Validate API key
        guard !apiKey.isEmpty else {
            completion(.failure(APIError.missingAPIKey(service: isClaude ? "Anthropic" : "OpenAI")))
            return
        }
        
        let url = isClaude ? URL(string: "https://api.anthropic.com/v1/messages")! : URL(string: "https://api.openai.com/v1/chat/completions")!
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        
        if isClaude {
            request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("2023-06-01", forHTTPHeaderField: "anthropic-version")
        } else {
            request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        var requestBody: [String: Any] = [:]
        
        if isClaude {
            var messages: [[String: String]] = conversation ?? []
            messages.append(["role": "user", "content": prompt])
            requestBody = [
                "model": model,
                "max_tokens": 4000,
                "messages": messages
            ]
        } else {
            var messages: [[String: String]] = conversation ?? []
            messages.append(["role": "user", "content": prompt])
            requestBody = [
                "model": model,
                "messages": messages,
                "max_tokens": 4000,
                "temperature": 0.7
            ]
        }
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        } catch {
            completion(.failure(error))
            return
        }
        
        // Track usage before making request
        ProductionAPIKeys.shared.trackUsage()
        
        // Configure URL session with optimized settings
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 45.0  // Reduced from 60s
        config.timeoutIntervalForResource = 90.0 // Reduced from 120s
        config.waitsForConnectivity = true // Wait for connectivity instead of failing immediately
        let session = URLSession(configuration: config)
        
        session.dataTask(with: request) { data, response, error in
            
            if let error = error {
                completion(.failure(error))
                return
            }
            
            // Enhanced HTTP response handling
            if let httpResponse = response as? HTTPURLResponse {
                print("üì° HTTP Status: \(httpResponse.statusCode)")
                
                switch httpResponse.statusCode {
                case 200:
                    break // Success, continue processing
                case 429:
                    // Rate limited - extract retry-after header if available
                    let retryAfter = httpResponse.value(forHTTPHeaderField: "Retry-After")
                        .flatMap { TimeInterval($0) }
                    completion(.failure(APIError.rateLimited(retryAfter: retryAfter)))
                    return
                case 500, 502, 503, 504:
                    // Server errors - retryable
                    let serviceName = httpResponse.url?.host ?? "API"
                    completion(.failure(APIError.serviceUnavailable(serviceName)))
                    return
                default:
                    let errorMsg = "HTTP \(httpResponse.statusCode): \(HTTPURLResponse.localizedString(forStatusCode: httpResponse.statusCode))"
                    completion(.failure(APIError.apiError(errorMsg)))
                    return
                }
            }
            
            guard let data = data else {
                completion(.failure(APIError.noDataReceived))
                return
            }
            
            do {
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                
                if isClaude {
                    if let content = json?["content"] as? [[String: Any]],
                       let firstContent = content.first,
                       let text = firstContent["text"] as? String {
                        completion(.success(text))
                    } else if let error = json?["error"] as? [String: Any],
                             let message = error["message"] as? String {
                        completion(.failure(APIError.apiError(message)))
                    } else {
                        completion(.failure(APIError.invalidResponse))
                    }
                } else {
                    if let choices = json?["choices"] as? [[String: Any]],
                       let firstChoice = choices.first,
                       let message = firstChoice["message"] as? [String: Any],
                       let content = message["content"] as? String {
                        completion(.success(content))
                    } else if let error = json?["error"] as? [String: Any],
                             let message = error["message"] as? String {
                        completion(.failure(APIError.apiError(message)))
                    } else {
                        completion(.failure(APIError.invalidResponse))
                    }
                }
            } catch {
                completion(.failure(error))
            }
        }.resume()
    }
    
    // MARK: - Retry Logic Helpers
    
    private func shouldRetry(error: Error) -> Bool {
        if let apiError = error as? APIError {
            switch apiError {
            case .rateLimited, .serviceUnavailable:
                return true
            default:
                return false
            }
        }
        
        // Retry on network errors
        if let urlError = error as? URLError {
            switch urlError.code {
            case .timedOut, .networkConnectionLost, .notConnectedToInternet, .cannotConnectToHost:
                return true
            default:
                return false
            }
        }
        
        return false
    }
    
    private func calculateDelay(for attempt: Int, error: Error) -> TimeInterval {
        // Check if the error includes a retry-after hint
        if let apiError = error as? APIError,
           case .rateLimited(let retryAfter) = apiError,
           let retryAfter = retryAfter {
            return min(retryAfter, maxDelay)
        }
        
        // Exponential backoff with jitter
        let exponentialDelay = baseDelay * pow(2.0, Double(attempt - 1))
        let jitter = Double.random(in: 0.5...1.5) // Add randomness to prevent thundering herd
        let delay = exponentialDelay * jitter
        
        return min(delay, maxDelay)
    }
    
    // MARK: - Circuit Breaker Implementation
    
    private func canMakeRequest() -> Bool {
        switch circuitBreakerState {
        case .closed:
            return true
        case .open:
            // Check if recovery timeout has passed
            if let lastFailure = lastFailureTime,
               Date().timeIntervalSince(lastFailure) >= recoveryTimeout {
                print("üîÑ Circuit breaker: Attempting recovery (half-open state)")
                circuitBreakerState = .halfOpen
                return true
            }
            print("‚ö° Circuit breaker: Open - blocking request")
            return false
        case .halfOpen:
            return true
        }
    }
    
    private func recordSuccess() {
        if circuitBreakerState == .halfOpen {
            print("‚úÖ Circuit breaker: Service recovered - closing circuit")
            circuitBreakerState = .closed
        }
        failureCount = 0
        lastFailureTime = nil
    }
    
    private func recordFailure() {
        failureCount += 1
        lastFailureTime = Date()
        
        if circuitBreakerState == .halfOpen {
            print("‚ùå Circuit breaker: Recovery failed - reopening circuit")
            circuitBreakerState = .open
        } else if failureCount >= failureThreshold {
            print("‚ö° Circuit breaker: Failure threshold reached - opening circuit")
            circuitBreakerState = .open
        }
    }
    
    /// Simple connectivity test for debugging
    func testConnectivity(completion: @escaping (Bool, String) -> Void) {
        print("üß™ Testing basic network connectivity...")
        
        let testURL = URL(string: "https://httpbin.org/get")!
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 10.0
        let session = URLSession(configuration: config)
        
        session.dataTask(with: testURL) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    print("üö´ Basic connectivity test FAILED: \(error.localizedDescription)")
                    completion(false, error.localizedDescription)
                } else if let httpResponse = response as? HTTPURLResponse {
                    print("‚úÖ Basic connectivity test PASSED: HTTP \(httpResponse.statusCode)")
                    completion(true, "Success")
                } else {
                    print("‚ùì Connectivity test unclear")
                    completion(false, "Unknown response")
                }
            }
        }.resume()
    }
}

// MARK: - API Errors

enum APIError: LocalizedError, Equatable {
    case missingAPIKey(service: String)
    case usageLimitExceeded(used: Int, limit: Int)
    case rateLimited(retryAfter: TimeInterval?)
    case serviceUnavailable(String)
    case apiError(String)
    case invalidResponse
    case noDataReceived
    case maxRetriesExceeded
    
    var errorDescription: String? {
        switch self {
        case .missingAPIKey(let service):
            return "\(service) API key not configured"
        case .usageLimitExceeded(let used, let limit):
            return "Daily usage limit exceeded (\(used)/\(limit)). Try again tomorrow or upgrade to Pro."
        case .rateLimited(let retryAfter):
            if let retryAfter = retryAfter {
                return "Rate limit reached. Please wait \(Int(retryAfter)) seconds and try again."
            } else {
                return "Rate limit reached. Please wait a moment and try again."
            }
        case .serviceUnavailable(let service):
            return "\(service) is temporarily unavailable. Trying backup service..."
        case .apiError(let message):
            return "API Error: \(message)"
        case .invalidResponse:
            return "Invalid response from API"
        case .noDataReceived:
            return "No data received from API"
        case .maxRetriesExceeded:
            return "Service temporarily unavailable. Please try again in a few minutes."
        }
    }
}
